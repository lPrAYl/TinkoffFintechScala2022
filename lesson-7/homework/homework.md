# Домашнее задание

## 1. Игра виселица

В первом задании нужно реализовать игру "Виселица".
Правила можно почитать тут: https://ru.wikipedia.org/wiki/Виселица_(игра)
На лекции мы рассмотрели основные конструкции функционального программирования, а так же кратко познакомились с
таким типом, как Task - ленивой альтернативой scala.concurrent.Future.
В данном задании нам не понадобится глубокое понимание того, как работает `Task`.
Самые важные отличия:
* Task - это описание вычисления, а не само вычисление. Это значит, что `Task(1000)` никаких вычислений не запускает
  в отличие от `Future(1000)`. Можно сказать, что Task представляет собой ленивое вычисление.

* Т.к. Task - это описание вычисления, его нужно отдельно запускать. В момент запуска можно определить, какую стратегию
  исполнения использовать. Если для Future каждый вызов `Future.apply` приводит к запуску асинхронной задачи в другом потоке,
  то для `Task.apply` по умолчанию это не так и это можно контролировать прямо из кода. Поэтому такие конструкции, как
  `Task(100).map(_ * 1000)` не будут приводить к дорогим асинхронным вычислениям. Их можно считать быстрыми.


* В задании вам понадобятся методы `Task.apply`, `Task.map` и `Task.flatMap`

В задании нужно реализовать все `TODO` в `Hangman.scala` и проверить, что игра работает корректно.

**Запрещено** использовать мутабельные переменные, глобальное состояние, и функции с сайд-эффектами

## 2. Классы типов

На лекции мы говорили, что классно собирать программы из блоков, как лего: когда мы собираем
из двух самых маленьких блоков один средний, далее к этому блоку мы снова можем добавить маленький блок,
а можем добавить и средний и даже блок большего размера. Это работает до тех пор, пока наши блоки имеет
общий "интерфейс", т.е. способны компоноваться друг с другом. Это свойство мы называли composability.
Мы можем скомпоновать два экзепляра `Try` получив на выходе `Try`. Можем компоновать `Option`, `Future` и 
даже `java.util.concarrent.CompletableFuture`.

А можно ли написать такую функцию, которая умеет компоновать между собой заранее неизвестные типы ?
Оказывается, можно и тут нам помогают классы типов. 

```scala
def transform[F[_] : FlatMap, T](value: T)
                                (initialTransform: Transform[F, T],
                                 transformations: Transform[F, T]*): F[T] = {
    transformations
      .foldLeft(initialTransform(value)) { (transformed, nextTransformation) =>
        transformed.flatMap(nextTransformation)
      }
  }
```

Функция transform умеет компоновать с помощью flatMap любый типы `T` до тех пор, пока для таких типов 
определен класс типов `FlatMap`.

Более того, `T` может быть не только нашим собственным типом или типом из стандартной библиотеки scala.
`T` может быть из библиотеки `java` !

### Recoverable

* Необходимо реализовать класс типов `ru.tinkoff.typeclass.Recoverable` для `Try` и `Future`
* "Спецификацией" поведения класса типов можно считать тест: `ru.tinkoff.typeclass.RecoverableTest`

Подсказка: обратите внимание на реализацию `ru.tinkoff.typeclass.FlatMap`

### Recoverable для CompletableFuture* (усложненное задание, не обязательно к выполнению)
Тайпклассы можно реализовывать, в том числе и для классов из java.
* Необходимо реализовать класс типов для `java.util.concarrent.CompletableFuture`
* Написать тест, который проверяет его корректность
  
RecoverableFutureTest
  RecoverableTest
  RecoverableTryTest

### Validated

На лекции мы познакомились с типом Validated из библиотеки cats. Validated оказался довольно нетипичным типом, т.к.
для него не определен метод `flatMap` с семантикой fail-fast. Вместо него доступен синтаксис `Tuple.mapN`,
который позволяет аккумулировать ошибки.
В данном задании предлагается реализовать упрощенную версию типа Validated.
Требуется реализовать:
* Экземпляр тайпкласса `ru.tinkoff.typeclass.ParMappable` для `ru.tinkoff.typeclass.Validated`
* Синтаксис для `mapN`, который будет доступен для кортежей размерности 2
* Убедиться, что проходят тесты в `ru.tinkoff.typeclass.ParMappableForValidatedTest`
